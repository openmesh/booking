// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/openmesh/booking/ent/auth"
	"github.com/openmesh/booking/ent/booking"
	"github.com/openmesh/booking/ent/bookingmetadatum"
	"github.com/openmesh/booking/ent/organization"
	"github.com/openmesh/booking/ent/organizationownership"
	"github.com/openmesh/booking/ent/predicate"
	"github.com/openmesh/booking/ent/resource"
	"github.com/openmesh/booking/ent/slot"
	"github.com/openmesh/booking/ent/unavailability"
	"github.com/openmesh/booking/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuth                  = "Auth"
	TypeBooking               = "Booking"
	TypeBookingMetadatum      = "BookingMetadatum"
	TypeOrganization          = "Organization"
	TypeOrganizationOwnership = "OrganizationOwnership"
	TypeResource              = "Resource"
	TypeSlot                  = "Slot"
	TypeUnavailability        = "Unavailability"
	TypeUser                  = "User"
)

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op            Op
	typ           string
	id            *int
	createdAt     *time.Time
	updatedAt     *time.Time
	source        *string
	sourceId      *string
	accessToken   *string
	refreshToken  *string
	expiry        *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Auth, error)
	predicates    []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id int) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "createdAt" field.
func (m *AuthMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AuthMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AuthMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AuthMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AuthMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AuthMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetSource sets the "source" field.
func (m *AuthMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AuthMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AuthMutation) ResetSource() {
	m.source = nil
}

// SetSourceId sets the "sourceId" field.
func (m *AuthMutation) SetSourceId(s string) {
	m.sourceId = &s
}

// SourceId returns the value of the "sourceId" field in the mutation.
func (m *AuthMutation) SourceId() (r string, exists bool) {
	v := m.sourceId
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceId returns the old "sourceId" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldSourceId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceId: %w", err)
	}
	return oldValue.SourceId, nil
}

// ResetSourceId resets all changes to the "sourceId" field.
func (m *AuthMutation) ResetSourceId() {
	m.sourceId = nil
}

// SetAccessToken sets the "accessToken" field.
func (m *AuthMutation) SetAccessToken(s string) {
	m.accessToken = &s
}

// AccessToken returns the value of the "accessToken" field in the mutation.
func (m *AuthMutation) AccessToken() (r string, exists bool) {
	v := m.accessToken
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "accessToken" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldAccessToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "accessToken" field.
func (m *AuthMutation) ClearAccessToken() {
	m.accessToken = nil
	m.clearedFields[auth.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "accessToken" field was cleared in this mutation.
func (m *AuthMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[auth.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "accessToken" field.
func (m *AuthMutation) ResetAccessToken() {
	m.accessToken = nil
	delete(m.clearedFields, auth.FieldAccessToken)
}

// SetRefreshToken sets the "refreshToken" field.
func (m *AuthMutation) SetRefreshToken(s string) {
	m.refreshToken = &s
}

// RefreshToken returns the value of the "refreshToken" field in the mutation.
func (m *AuthMutation) RefreshToken() (r string, exists bool) {
	v := m.refreshToken
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refreshToken" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldRefreshToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refreshToken" field.
func (m *AuthMutation) ClearRefreshToken() {
	m.refreshToken = nil
	m.clearedFields[auth.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refreshToken" field was cleared in this mutation.
func (m *AuthMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[auth.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refreshToken" field.
func (m *AuthMutation) ResetRefreshToken() {
	m.refreshToken = nil
	delete(m.clearedFields, auth.FieldRefreshToken)
}

// SetExpiry sets the "expiry" field.
func (m *AuthMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *AuthMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldExpiry(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *AuthMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[auth.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *AuthMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[auth.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *AuthMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, auth.FieldExpiry)
}

// SetUserId sets the "userId" field.
func (m *AuthMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *AuthMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *AuthMutation) ResetUserId() {
	m.user = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AuthMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuthMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuthMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AuthMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuthMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.createdAt != nil {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.source != nil {
		fields = append(fields, auth.FieldSource)
	}
	if m.sourceId != nil {
		fields = append(fields, auth.FieldSourceId)
	}
	if m.accessToken != nil {
		fields = append(fields, auth.FieldAccessToken)
	}
	if m.refreshToken != nil {
		fields = append(fields, auth.FieldRefreshToken)
	}
	if m.expiry != nil {
		fields = append(fields, auth.FieldExpiry)
	}
	if m.user != nil {
		fields = append(fields, auth.FieldUserId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldCreatedAt:
		return m.CreatedAt()
	case auth.FieldUpdatedAt:
		return m.UpdatedAt()
	case auth.FieldSource:
		return m.Source()
	case auth.FieldSourceId:
		return m.SourceId()
	case auth.FieldAccessToken:
		return m.AccessToken()
	case auth.FieldRefreshToken:
		return m.RefreshToken()
	case auth.FieldExpiry:
		return m.Expiry()
	case auth.FieldUserId:
		return m.UserId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auth.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case auth.FieldSource:
		return m.OldSource(ctx)
	case auth.FieldSourceId:
		return m.OldSourceId(ctx)
	case auth.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case auth.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case auth.FieldExpiry:
		return m.OldExpiry(ctx)
	case auth.FieldUserId:
		return m.OldUserId(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auth.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case auth.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case auth.FieldSourceId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceId(v)
		return nil
	case auth.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case auth.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case auth.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case auth.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auth.FieldAccessToken) {
		fields = append(fields, auth.FieldAccessToken)
	}
	if m.FieldCleared(auth.FieldRefreshToken) {
		fields = append(fields, auth.FieldRefreshToken)
	}
	if m.FieldCleared(auth.FieldExpiry) {
		fields = append(fields, auth.FieldExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	switch name {
	case auth.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	case auth.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case auth.FieldExpiry:
		m.ClearExpiry()
		return nil
	}
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auth.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case auth.FieldSource:
		m.ResetSource()
		return nil
	case auth.FieldSourceId:
		m.ResetSourceId()
		return nil
	case auth.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case auth.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case auth.FieldExpiry:
		m.ResetExpiry()
		return nil
	case auth.FieldUserId:
		m.ResetUserId()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, auth.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auth.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, auth.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	switch name {
	case auth.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	switch name {
	case auth.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	switch name {
	case auth.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Auth edge %s", name)
}

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op              Op
	typ             string
	id              *int
	createdAt       *time.Time
	updatedAt       *time.Time
	status          *string
	startTime       *time.Time
	endTime         *time.Time
	clearedFields   map[string]struct{}
	metadata        map[int]struct{}
	removedmetadata map[int]struct{}
	clearedmetadata bool
	resource        *int
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*Booking, error)
	predicates      []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id int) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "createdAt" field.
func (m *BookingMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *BookingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *BookingMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *BookingMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *BookingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *BookingMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// SetStartTime sets the "startTime" field.
func (m *BookingMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *BookingMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *BookingMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *BookingMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *BookingMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *BookingMutation) ResetEndTime() {
	m.endTime = nil
}

// SetResourceId sets the "resourceId" field.
func (m *BookingMutation) SetResourceId(i int) {
	m.resource = &i
}

// ResourceId returns the value of the "resourceId" field in the mutation.
func (m *BookingMutation) ResourceId() (r int, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceId returns the old "resourceId" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldResourceId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResourceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResourceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceId: %w", err)
	}
	return oldValue.ResourceId, nil
}

// ResetResourceId resets all changes to the "resourceId" field.
func (m *BookingMutation) ResetResourceId() {
	m.resource = nil
}

// AddMetadatumIDs adds the "metadata" edge to the BookingMetadatum entity by ids.
func (m *BookingMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the BookingMetadatum entity.
func (m *BookingMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the BookingMetadatum entity was cleared.
func (m *BookingMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the BookingMetadatum entity by IDs.
func (m *BookingMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the BookingMetadatum entity.
func (m *BookingMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *BookingMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *BookingMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// SetResourceID sets the "resource" edge to the Resource entity by id.
func (m *BookingMutation) SetResourceID(id int) {
	m.resource = &id
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *BookingMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *BookingMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceID returns the "resource" edge ID in the mutation.
func (m *BookingMutation) ResourceID() (id int, exists bool) {
	if m.resource != nil {
		return *m.resource, true
	}
	return
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) ResourceIDs() (ids []int) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *BookingMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.createdAt != nil {
		fields = append(fields, booking.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, booking.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	if m.startTime != nil {
		fields = append(fields, booking.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, booking.FieldEndTime)
	}
	if m.resource != nil {
		fields = append(fields, booking.FieldResourceId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldCreatedAt:
		return m.CreatedAt()
	case booking.FieldUpdatedAt:
		return m.UpdatedAt()
	case booking.FieldStatus:
		return m.Status()
	case booking.FieldStartTime:
		return m.StartTime()
	case booking.FieldEndTime:
		return m.EndTime()
	case booking.FieldResourceId:
		return m.ResourceId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case booking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	case booking.FieldStartTime:
		return m.OldStartTime(ctx)
	case booking.FieldEndTime:
		return m.OldEndTime(ctx)
	case booking.FieldResourceId:
		return m.OldResourceId(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case booking.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case booking.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case booking.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case booking.FieldResourceId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceId(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case booking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	case booking.FieldStartTime:
		m.ResetStartTime()
		return nil
	case booking.FieldEndTime:
		m.ResetEndTime()
		return nil
	case booking.FieldResourceId:
		m.ResetResourceId()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, booking.EdgeMetadata)
	}
	if m.resource != nil {
		edges = append(edges, booking.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case booking.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmetadata != nil {
		edges = append(edges, booking.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, booking.EdgeMetadata)
	}
	if m.clearedresource {
		edges = append(edges, booking.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeMetadata:
		return m.clearedmetadata
	case booking.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case booking.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// BookingMetadatumMutation represents an operation that mutates the BookingMetadatum nodes in the graph.
type BookingMetadatumMutation struct {
	config
	op             Op
	typ            string
	id             *int
	key            *string
	value          *string
	clearedFields  map[string]struct{}
	booking        *int
	clearedbooking bool
	done           bool
	oldValue       func(context.Context) (*BookingMetadatum, error)
	predicates     []predicate.BookingMetadatum
}

var _ ent.Mutation = (*BookingMetadatumMutation)(nil)

// bookingmetadatumOption allows management of the mutation configuration using functional options.
type bookingmetadatumOption func(*BookingMetadatumMutation)

// newBookingMetadatumMutation creates new mutation for the BookingMetadatum entity.
func newBookingMetadatumMutation(c config, op Op, opts ...bookingmetadatumOption) *BookingMetadatumMutation {
	m := &BookingMetadatumMutation{
		config:        c,
		op:            op,
		typ:           TypeBookingMetadatum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingMetadatumID sets the ID field of the mutation.
func withBookingMetadatumID(id int) bookingmetadatumOption {
	return func(m *BookingMetadatumMutation) {
		var (
			err   error
			once  sync.Once
			value *BookingMetadatum
		)
		m.oldValue = func(ctx context.Context) (*BookingMetadatum, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookingMetadatum.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookingMetadatum sets the old BookingMetadatum of the mutation.
func withBookingMetadatum(node *BookingMetadatum) bookingmetadatumOption {
	return func(m *BookingMetadatumMutation) {
		m.oldValue = func(context.Context) (*BookingMetadatum, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMetadatumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMetadatumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMetadatumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetKey sets the "key" field.
func (m *BookingMetadatumMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *BookingMetadatumMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the BookingMetadatum entity.
// If the BookingMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMetadatumMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *BookingMetadatumMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *BookingMetadatumMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *BookingMetadatumMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the BookingMetadatum entity.
// If the BookingMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMetadatumMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *BookingMetadatumMutation) ResetValue() {
	m.value = nil
}

// SetBookingId sets the "bookingId" field.
func (m *BookingMetadatumMutation) SetBookingId(i int) {
	m.booking = &i
}

// BookingId returns the value of the "bookingId" field in the mutation.
func (m *BookingMetadatumMutation) BookingId() (r int, exists bool) {
	v := m.booking
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingId returns the old "bookingId" field's value of the BookingMetadatum entity.
// If the BookingMetadatum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMetadatumMutation) OldBookingId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookingId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookingId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingId: %w", err)
	}
	return oldValue.BookingId, nil
}

// ResetBookingId resets all changes to the "bookingId" field.
func (m *BookingMetadatumMutation) ResetBookingId() {
	m.booking = nil
}

// SetBookingID sets the "booking" edge to the Booking entity by id.
func (m *BookingMetadatumMutation) SetBookingID(id int) {
	m.booking = &id
}

// ClearBooking clears the "booking" edge to the Booking entity.
func (m *BookingMetadatumMutation) ClearBooking() {
	m.clearedbooking = true
}

// BookingCleared reports if the "booking" edge to the Booking entity was cleared.
func (m *BookingMetadatumMutation) BookingCleared() bool {
	return m.clearedbooking
}

// BookingID returns the "booking" edge ID in the mutation.
func (m *BookingMetadatumMutation) BookingID() (id int, exists bool) {
	if m.booking != nil {
		return *m.booking, true
	}
	return
}

// BookingIDs returns the "booking" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookingID instead. It exists only for internal usage by the builders.
func (m *BookingMetadatumMutation) BookingIDs() (ids []int) {
	if id := m.booking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBooking resets all changes to the "booking" edge.
func (m *BookingMetadatumMutation) ResetBooking() {
	m.booking = nil
	m.clearedbooking = false
}

// Where appends a list predicates to the BookingMetadatumMutation builder.
func (m *BookingMetadatumMutation) Where(ps ...predicate.BookingMetadatum) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BookingMetadatumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BookingMetadatum).
func (m *BookingMetadatumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMetadatumMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, bookingmetadatum.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, bookingmetadatum.FieldValue)
	}
	if m.booking != nil {
		fields = append(fields, bookingmetadatum.FieldBookingId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMetadatumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookingmetadatum.FieldKey:
		return m.Key()
	case bookingmetadatum.FieldValue:
		return m.Value()
	case bookingmetadatum.FieldBookingId:
		return m.BookingId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMetadatumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookingmetadatum.FieldKey:
		return m.OldKey(ctx)
	case bookingmetadatum.FieldValue:
		return m.OldValue(ctx)
	case bookingmetadatum.FieldBookingId:
		return m.OldBookingId(ctx)
	}
	return nil, fmt.Errorf("unknown BookingMetadatum field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMetadatumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookingmetadatum.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case bookingmetadatum.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case bookingmetadatum.FieldBookingId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingId(v)
		return nil
	}
	return fmt.Errorf("unknown BookingMetadatum field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMetadatumMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMetadatumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMetadatumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BookingMetadatum numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMetadatumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMetadatumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMetadatumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BookingMetadatum nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMetadatumMutation) ResetField(name string) error {
	switch name {
	case bookingmetadatum.FieldKey:
		m.ResetKey()
		return nil
	case bookingmetadatum.FieldValue:
		m.ResetValue()
		return nil
	case bookingmetadatum.FieldBookingId:
		m.ResetBookingId()
		return nil
	}
	return fmt.Errorf("unknown BookingMetadatum field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMetadatumMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booking != nil {
		edges = append(edges, bookingmetadatum.EdgeBooking)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMetadatumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookingmetadatum.EdgeBooking:
		if id := m.booking; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMetadatumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMetadatumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMetadatumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooking {
		edges = append(edges, bookingmetadatum.EdgeBooking)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMetadatumMutation) EdgeCleared(name string) bool {
	switch name {
	case bookingmetadatum.EdgeBooking:
		return m.clearedbooking
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMetadatumMutation) ClearEdge(name string) error {
	switch name {
	case bookingmetadatum.EdgeBooking:
		m.ClearBooking()
		return nil
	}
	return fmt.Errorf("unknown BookingMetadatum unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMetadatumMutation) ResetEdge(name string) error {
	switch name {
	case bookingmetadatum.EdgeBooking:
		m.ResetBooking()
		return nil
	}
	return fmt.Errorf("unknown BookingMetadatum edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op               Op
	typ              string
	id               *int
	createdAt        *time.Time
	updatedAt        *time.Time
	name             *string
	publicKey        *string
	privateKey       *string
	clearedFields    map[string]struct{}
	users            map[int]struct{}
	removedusers     map[int]struct{}
	clearedusers     bool
	resources        map[int]struct{}
	removedresources map[int]struct{}
	clearedresources bool
	done             bool
	oldValue         func(context.Context) (*Organization, error)
	predicates       []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "createdAt" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetPublicKey sets the "publicKey" field.
func (m *OrganizationMutation) SetPublicKey(s string) {
	m.publicKey = &s
}

// PublicKey returns the value of the "publicKey" field in the mutation.
func (m *OrganizationMutation) PublicKey() (r string, exists bool) {
	v := m.publicKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "publicKey" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "publicKey" field.
func (m *OrganizationMutation) ResetPublicKey() {
	m.publicKey = nil
}

// SetPrivateKey sets the "privateKey" field.
func (m *OrganizationMutation) SetPrivateKey(s string) {
	m.privateKey = &s
}

// PrivateKey returns the value of the "privateKey" field in the mutation.
func (m *OrganizationMutation) PrivateKey() (r string, exists bool) {
	v := m.privateKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "privateKey" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ResetPrivateKey resets all changes to the "privateKey" field.
func (m *OrganizationMutation) ResetPrivateKey() {
	m.privateKey = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddResourceIDs adds the "resources" edge to the Resource entity by ids.
func (m *OrganizationMutation) AddResourceIDs(ids ...int) {
	if m.resources == nil {
		m.resources = make(map[int]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the Resource entity.
func (m *OrganizationMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the Resource entity was cleared.
func (m *OrganizationMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the Resource entity by IDs.
func (m *OrganizationMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresources == nil {
		m.removedresources = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the Resource entity.
func (m *OrganizationMutation) RemovedResourcesIDs() (ids []int) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *OrganizationMutation) ResourcesIDs() (ids []int) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *OrganizationMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.createdAt != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.publicKey != nil {
		fields = append(fields, organization.FieldPublicKey)
	}
	if m.privateKey != nil {
		fields = append(fields, organization.FieldPrivateKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldName:
		return m.Name()
	case organization.FieldPublicKey:
		return m.PublicKey()
	case organization.FieldPrivateKey:
		return m.PrivateKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case organization.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case organization.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case organization.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.resources != nil {
		edges = append(edges, organization.EdgeResources)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedresources != nil {
		edges = append(edges, organization.EdgeResources)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedresources {
		edges = append(edges, organization.EdgeResources)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeResources:
		return m.clearedresources
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeResources:
		m.ResetResources()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationOwnershipMutation represents an operation that mutates the OrganizationOwnership nodes in the graph.
type OrganizationOwnershipMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*OrganizationOwnership, error)
	predicates          []predicate.OrganizationOwnership
}

var _ ent.Mutation = (*OrganizationOwnershipMutation)(nil)

// organizationownershipOption allows management of the mutation configuration using functional options.
type organizationownershipOption func(*OrganizationOwnershipMutation)

// newOrganizationOwnershipMutation creates new mutation for the OrganizationOwnership entity.
func newOrganizationOwnershipMutation(c config, op Op, opts ...organizationownershipOption) *OrganizationOwnershipMutation {
	m := &OrganizationOwnershipMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationOwnership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationOwnershipID sets the ID field of the mutation.
func withOrganizationOwnershipID(id int) organizationownershipOption {
	return func(m *OrganizationOwnershipMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationOwnership
		)
		m.oldValue = func(ctx context.Context) (*OrganizationOwnership, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationOwnership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationOwnership sets the old OrganizationOwnership of the mutation.
func withOrganizationOwnership(node *OrganizationOwnership) organizationownershipOption {
	return func(m *OrganizationOwnershipMutation) {
		m.oldValue = func(context.Context) (*OrganizationOwnership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationOwnershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationOwnershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationOwnershipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserId sets the "userId" field.
func (m *OrganizationOwnershipMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *OrganizationOwnershipMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the OrganizationOwnership entity.
// If the OrganizationOwnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationOwnershipMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *OrganizationOwnershipMutation) ResetUserId() {
	m.user = nil
}

// SetOrganizationId sets the "organizationId" field.
func (m *OrganizationOwnershipMutation) SetOrganizationId(i int) {
	m.organization = &i
}

// OrganizationId returns the value of the "organizationId" field in the mutation.
func (m *OrganizationOwnershipMutation) OrganizationId() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationId returns the old "organizationId" field's value of the OrganizationOwnership entity.
// If the OrganizationOwnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationOwnershipMutation) OldOrganizationId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrganizationId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrganizationId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationId: %w", err)
	}
	return oldValue.OrganizationId, nil
}

// ResetOrganizationId resets all changes to the "organizationId" field.
func (m *OrganizationOwnershipMutation) ResetOrganizationId() {
	m.organization = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OrganizationOwnershipMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationOwnershipMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationOwnershipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OrganizationOwnershipMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationOwnershipMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationOwnershipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationOwnershipMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationOwnershipMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationOwnershipMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationOwnershipMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationOwnershipMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationOwnershipMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the OrganizationOwnershipMutation builder.
func (m *OrganizationOwnershipMutation) Where(ps ...predicate.OrganizationOwnership) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrganizationOwnershipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrganizationOwnership).
func (m *OrganizationOwnershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationOwnershipMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user != nil {
		fields = append(fields, organizationownership.FieldUserId)
	}
	if m.organization != nil {
		fields = append(fields, organizationownership.FieldOrganizationId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationOwnershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationownership.FieldUserId:
		return m.UserId()
	case organizationownership.FieldOrganizationId:
		return m.OrganizationId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationOwnershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationownership.FieldUserId:
		return m.OldUserId(ctx)
	case organizationownership.FieldOrganizationId:
		return m.OldOrganizationId(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationOwnership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationOwnershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationownership.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case organizationownership.FieldOrganizationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationId(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationOwnership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationOwnershipMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationOwnershipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationOwnershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationOwnership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationOwnershipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationOwnershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationOwnershipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrganizationOwnership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationOwnershipMutation) ResetField(name string) error {
	switch name {
	case organizationownership.FieldUserId:
		m.ResetUserId()
		return nil
	case organizationownership.FieldOrganizationId:
		m.ResetOrganizationId()
		return nil
	}
	return fmt.Errorf("unknown OrganizationOwnership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationOwnershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, organizationownership.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, organizationownership.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationOwnershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationownership.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case organizationownership.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationOwnershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationOwnershipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationOwnershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, organizationownership.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, organizationownership.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationOwnershipMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationownership.EdgeUser:
		return m.cleareduser
	case organizationownership.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationOwnershipMutation) ClearEdge(name string) error {
	switch name {
	case organizationownership.EdgeUser:
		m.ClearUser()
		return nil
	case organizationownership.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationOwnership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationOwnershipMutation) ResetEdge(name string) error {
	switch name {
	case organizationownership.EdgeUser:
		m.ResetUser()
		return nil
	case organizationownership.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationOwnership edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	createdAt               *time.Time
	updatedAt               *time.Time
	name                    *string
	description             *string
	timezone                *string
	password                *string
	price                   *int
	addprice                *int
	bookingPrice            *int
	addbookingPrice         *int
	quantityAvailable       *int
	addquantityAvailable    *int
	clearedFields           map[string]struct{}
	slots                   map[int]struct{}
	removedslots            map[int]struct{}
	clearedslots            bool
	bookings                map[int]struct{}
	removedbookings         map[int]struct{}
	clearedbookings         bool
	unavailabilities        map[int]struct{}
	removedunavailabilities map[int]struct{}
	clearedunavailabilities bool
	organization            *int
	clearedorganization     bool
	done                    bool
	oldValue                func(context.Context) (*Resource, error)
	predicates              []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id int) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "createdAt" field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetName sets the "name" field.
func (m *ResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResourceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ResourceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResourceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ResourceMutation) ResetDescription() {
	m.description = nil
}

// SetTimezone sets the "timezone" field.
func (m *ResourceMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *ResourceMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *ResourceMutation) ResetTimezone() {
	m.timezone = nil
}

// SetPassword sets the "password" field.
func (m *ResourceMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ResourceMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *ResourceMutation) ResetPassword() {
	m.password = nil
}

// SetPrice sets the "price" field.
func (m *ResourceMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ResourceMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ResourceMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ResourceMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ResourceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetBookingPrice sets the "bookingPrice" field.
func (m *ResourceMutation) SetBookingPrice(i int) {
	m.bookingPrice = &i
	m.addbookingPrice = nil
}

// BookingPrice returns the value of the "bookingPrice" field in the mutation.
func (m *ResourceMutation) BookingPrice() (r int, exists bool) {
	v := m.bookingPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingPrice returns the old "bookingPrice" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldBookingPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingPrice: %w", err)
	}
	return oldValue.BookingPrice, nil
}

// AddBookingPrice adds i to the "bookingPrice" field.
func (m *ResourceMutation) AddBookingPrice(i int) {
	if m.addbookingPrice != nil {
		*m.addbookingPrice += i
	} else {
		m.addbookingPrice = &i
	}
}

// AddedBookingPrice returns the value that was added to the "bookingPrice" field in this mutation.
func (m *ResourceMutation) AddedBookingPrice() (r int, exists bool) {
	v := m.addbookingPrice
	if v == nil {
		return
	}
	return *v, true
}

// ResetBookingPrice resets all changes to the "bookingPrice" field.
func (m *ResourceMutation) ResetBookingPrice() {
	m.bookingPrice = nil
	m.addbookingPrice = nil
}

// SetOrganizationId sets the "organizationId" field.
func (m *ResourceMutation) SetOrganizationId(i int) {
	m.organization = &i
}

// OrganizationId returns the value of the "organizationId" field in the mutation.
func (m *ResourceMutation) OrganizationId() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationId returns the old "organizationId" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldOrganizationId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrganizationId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrganizationId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationId: %w", err)
	}
	return oldValue.OrganizationId, nil
}

// ResetOrganizationId resets all changes to the "organizationId" field.
func (m *ResourceMutation) ResetOrganizationId() {
	m.organization = nil
}

// SetQuantityAvailable sets the "quantityAvailable" field.
func (m *ResourceMutation) SetQuantityAvailable(i int) {
	m.quantityAvailable = &i
	m.addquantityAvailable = nil
}

// QuantityAvailable returns the value of the "quantityAvailable" field in the mutation.
func (m *ResourceMutation) QuantityAvailable() (r int, exists bool) {
	v := m.quantityAvailable
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityAvailable returns the old "quantityAvailable" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldQuantityAvailable(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityAvailable: %w", err)
	}
	return oldValue.QuantityAvailable, nil
}

// AddQuantityAvailable adds i to the "quantityAvailable" field.
func (m *ResourceMutation) AddQuantityAvailable(i int) {
	if m.addquantityAvailable != nil {
		*m.addquantityAvailable += i
	} else {
		m.addquantityAvailable = &i
	}
}

// AddedQuantityAvailable returns the value that was added to the "quantityAvailable" field in this mutation.
func (m *ResourceMutation) AddedQuantityAvailable() (r int, exists bool) {
	v := m.addquantityAvailable
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantityAvailable resets all changes to the "quantityAvailable" field.
func (m *ResourceMutation) ResetQuantityAvailable() {
	m.quantityAvailable = nil
	m.addquantityAvailable = nil
}

// AddSlotIDs adds the "slots" edge to the Slot entity by ids.
func (m *ResourceMutation) AddSlotIDs(ids ...int) {
	if m.slots == nil {
		m.slots = make(map[int]struct{})
	}
	for i := range ids {
		m.slots[ids[i]] = struct{}{}
	}
}

// ClearSlots clears the "slots" edge to the Slot entity.
func (m *ResourceMutation) ClearSlots() {
	m.clearedslots = true
}

// SlotsCleared reports if the "slots" edge to the Slot entity was cleared.
func (m *ResourceMutation) SlotsCleared() bool {
	return m.clearedslots
}

// RemoveSlotIDs removes the "slots" edge to the Slot entity by IDs.
func (m *ResourceMutation) RemoveSlotIDs(ids ...int) {
	if m.removedslots == nil {
		m.removedslots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.slots, ids[i])
		m.removedslots[ids[i]] = struct{}{}
	}
}

// RemovedSlots returns the removed IDs of the "slots" edge to the Slot entity.
func (m *ResourceMutation) RemovedSlotsIDs() (ids []int) {
	for id := range m.removedslots {
		ids = append(ids, id)
	}
	return
}

// SlotsIDs returns the "slots" edge IDs in the mutation.
func (m *ResourceMutation) SlotsIDs() (ids []int) {
	for id := range m.slots {
		ids = append(ids, id)
	}
	return
}

// ResetSlots resets all changes to the "slots" edge.
func (m *ResourceMutation) ResetSlots() {
	m.slots = nil
	m.clearedslots = false
	m.removedslots = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *ResourceMutation) AddBookingIDs(ids ...int) {
	if m.bookings == nil {
		m.bookings = make(map[int]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *ResourceMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *ResourceMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *ResourceMutation) RemoveBookingIDs(ids ...int) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *ResourceMutation) RemovedBookingsIDs() (ids []int) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *ResourceMutation) BookingsIDs() (ids []int) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *ResourceMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddUnavailabilityIDs adds the "unavailabilities" edge to the Unavailability entity by ids.
func (m *ResourceMutation) AddUnavailabilityIDs(ids ...int) {
	if m.unavailabilities == nil {
		m.unavailabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.unavailabilities[ids[i]] = struct{}{}
	}
}

// ClearUnavailabilities clears the "unavailabilities" edge to the Unavailability entity.
func (m *ResourceMutation) ClearUnavailabilities() {
	m.clearedunavailabilities = true
}

// UnavailabilitiesCleared reports if the "unavailabilities" edge to the Unavailability entity was cleared.
func (m *ResourceMutation) UnavailabilitiesCleared() bool {
	return m.clearedunavailabilities
}

// RemoveUnavailabilityIDs removes the "unavailabilities" edge to the Unavailability entity by IDs.
func (m *ResourceMutation) RemoveUnavailabilityIDs(ids ...int) {
	if m.removedunavailabilities == nil {
		m.removedunavailabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.unavailabilities, ids[i])
		m.removedunavailabilities[ids[i]] = struct{}{}
	}
}

// RemovedUnavailabilities returns the removed IDs of the "unavailabilities" edge to the Unavailability entity.
func (m *ResourceMutation) RemovedUnavailabilitiesIDs() (ids []int) {
	for id := range m.removedunavailabilities {
		ids = append(ids, id)
	}
	return
}

// UnavailabilitiesIDs returns the "unavailabilities" edge IDs in the mutation.
func (m *ResourceMutation) UnavailabilitiesIDs() (ids []int) {
	for id := range m.unavailabilities {
		ids = append(ids, id)
	}
	return
}

// ResetUnavailabilities resets all changes to the "unavailabilities" edge.
func (m *ResourceMutation) ResetUnavailabilities() {
	m.unavailabilities = nil
	m.clearedunavailabilities = false
	m.removedunavailabilities = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *ResourceMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ResourceMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ResourceMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *ResourceMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ResourceMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ResourceMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.createdAt != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, resource.FieldName)
	}
	if m.description != nil {
		fields = append(fields, resource.FieldDescription)
	}
	if m.timezone != nil {
		fields = append(fields, resource.FieldTimezone)
	}
	if m.password != nil {
		fields = append(fields, resource.FieldPassword)
	}
	if m.price != nil {
		fields = append(fields, resource.FieldPrice)
	}
	if m.bookingPrice != nil {
		fields = append(fields, resource.FieldBookingPrice)
	}
	if m.organization != nil {
		fields = append(fields, resource.FieldOrganizationId)
	}
	if m.quantityAvailable != nil {
		fields = append(fields, resource.FieldQuantityAvailable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	case resource.FieldName:
		return m.Name()
	case resource.FieldDescription:
		return m.Description()
	case resource.FieldTimezone:
		return m.Timezone()
	case resource.FieldPassword:
		return m.Password()
	case resource.FieldPrice:
		return m.Price()
	case resource.FieldBookingPrice:
		return m.BookingPrice()
	case resource.FieldOrganizationId:
		return m.OrganizationId()
	case resource.FieldQuantityAvailable:
		return m.QuantityAvailable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resource.FieldName:
		return m.OldName(ctx)
	case resource.FieldDescription:
		return m.OldDescription(ctx)
	case resource.FieldTimezone:
		return m.OldTimezone(ctx)
	case resource.FieldPassword:
		return m.OldPassword(ctx)
	case resource.FieldPrice:
		return m.OldPrice(ctx)
	case resource.FieldBookingPrice:
		return m.OldBookingPrice(ctx)
	case resource.FieldOrganizationId:
		return m.OldOrganizationId(ctx)
	case resource.FieldQuantityAvailable:
		return m.OldQuantityAvailable(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resource.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resource.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case resource.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case resource.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case resource.FieldBookingPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingPrice(v)
		return nil
	case resource.FieldOrganizationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationId(v)
		return nil
	case resource.FieldQuantityAvailable:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityAvailable(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, resource.FieldPrice)
	}
	if m.addbookingPrice != nil {
		fields = append(fields, resource.FieldBookingPrice)
	}
	if m.addquantityAvailable != nil {
		fields = append(fields, resource.FieldQuantityAvailable)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldPrice:
		return m.AddedPrice()
	case resource.FieldBookingPrice:
		return m.AddedBookingPrice()
	case resource.FieldQuantityAvailable:
		return m.AddedQuantityAvailable()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resource.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case resource.FieldBookingPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookingPrice(v)
		return nil
	case resource.FieldQuantityAvailable:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityAvailable(v)
		return nil
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resource.FieldName:
		m.ResetName()
		return nil
	case resource.FieldDescription:
		m.ResetDescription()
		return nil
	case resource.FieldTimezone:
		m.ResetTimezone()
		return nil
	case resource.FieldPassword:
		m.ResetPassword()
		return nil
	case resource.FieldPrice:
		m.ResetPrice()
		return nil
	case resource.FieldBookingPrice:
		m.ResetBookingPrice()
		return nil
	case resource.FieldOrganizationId:
		m.ResetOrganizationId()
		return nil
	case resource.FieldQuantityAvailable:
		m.ResetQuantityAvailable()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.slots != nil {
		edges = append(edges, resource.EdgeSlots)
	}
	if m.bookings != nil {
		edges = append(edges, resource.EdgeBookings)
	}
	if m.unavailabilities != nil {
		edges = append(edges, resource.EdgeUnavailabilities)
	}
	if m.organization != nil {
		edges = append(edges, resource.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.slots))
		for id := range m.slots {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeUnavailabilities:
		ids := make([]ent.Value, 0, len(m.unavailabilities))
		for id := range m.unavailabilities {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedslots != nil {
		edges = append(edges, resource.EdgeSlots)
	}
	if m.removedbookings != nil {
		edges = append(edges, resource.EdgeBookings)
	}
	if m.removedunavailabilities != nil {
		edges = append(edges, resource.EdgeUnavailabilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.removedslots))
		for id := range m.removedslots {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeUnavailabilities:
		ids := make([]ent.Value, 0, len(m.removedunavailabilities))
		for id := range m.removedunavailabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedslots {
		edges = append(edges, resource.EdgeSlots)
	}
	if m.clearedbookings {
		edges = append(edges, resource.EdgeBookings)
	}
	if m.clearedunavailabilities {
		edges = append(edges, resource.EdgeUnavailabilities)
	}
	if m.clearedorganization {
		edges = append(edges, resource.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeSlots:
		return m.clearedslots
	case resource.EdgeBookings:
		return m.clearedbookings
	case resource.EdgeUnavailabilities:
		return m.clearedunavailabilities
	case resource.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	case resource.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeSlots:
		m.ResetSlots()
		return nil
	case resource.EdgeBookings:
		m.ResetBookings()
		return nil
	case resource.EdgeUnavailabilities:
		m.ResetUnavailabilities()
		return nil
	case resource.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// SlotMutation represents an operation that mutates the Slot nodes in the graph.
type SlotMutation struct {
	config
	op              Op
	typ             string
	id              *int
	day             *string
	startTime       *string
	endTime         *string
	quantity        *int
	addquantity     *int
	clearedFields   map[string]struct{}
	resource        *int
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*Slot, error)
	predicates      []predicate.Slot
}

var _ ent.Mutation = (*SlotMutation)(nil)

// slotOption allows management of the mutation configuration using functional options.
type slotOption func(*SlotMutation)

// newSlotMutation creates new mutation for the Slot entity.
func newSlotMutation(c config, op Op, opts ...slotOption) *SlotMutation {
	m := &SlotMutation{
		config:        c,
		op:            op,
		typ:           TypeSlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSlotID sets the ID field of the mutation.
func withSlotID(id int) slotOption {
	return func(m *SlotMutation) {
		var (
			err   error
			once  sync.Once
			value *Slot
		)
		m.oldValue = func(ctx context.Context) (*Slot, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Slot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSlot sets the old Slot of the mutation.
func withSlot(node *Slot) slotOption {
	return func(m *SlotMutation) {
		m.oldValue = func(context.Context) (*Slot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SlotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDay sets the "day" field.
func (m *SlotMutation) SetDay(s string) {
	m.day = &s
}

// Day returns the value of the "day" field in the mutation.
func (m *SlotMutation) Day() (r string, exists bool) {
	v := m.day
	if v == nil {
		return
	}
	return *v, true
}

// OldDay returns the old "day" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldDay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay: %w", err)
	}
	return oldValue.Day, nil
}

// ResetDay resets all changes to the "day" field.
func (m *SlotMutation) ResetDay() {
	m.day = nil
}

// SetStartTime sets the "startTime" field.
func (m *SlotMutation) SetStartTime(s string) {
	m.startTime = &s
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *SlotMutation) StartTime() (r string, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *SlotMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *SlotMutation) SetEndTime(s string) {
	m.endTime = &s
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *SlotMutation) EndTime() (r string, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *SlotMutation) ResetEndTime() {
	m.endTime = nil
}

// SetQuantity sets the "quantity" field.
func (m *SlotMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *SlotMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldQuantity(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *SlotMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *SlotMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *SlotMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[slot.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *SlotMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[slot.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *SlotMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, slot.FieldQuantity)
}

// SetResourceId sets the "resourceId" field.
func (m *SlotMutation) SetResourceId(i int) {
	m.resource = &i
}

// ResourceId returns the value of the "resourceId" field in the mutation.
func (m *SlotMutation) ResourceId() (r int, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceId returns the old "resourceId" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldResourceId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResourceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResourceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceId: %w", err)
	}
	return oldValue.ResourceId, nil
}

// ResetResourceId resets all changes to the "resourceId" field.
func (m *SlotMutation) ResetResourceId() {
	m.resource = nil
}

// SetResourceID sets the "resource" edge to the Resource entity by id.
func (m *SlotMutation) SetResourceID(id int) {
	m.resource = &id
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *SlotMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *SlotMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceID returns the "resource" edge ID in the mutation.
func (m *SlotMutation) ResourceID() (id int, exists bool) {
	if m.resource != nil {
		return *m.resource, true
	}
	return
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *SlotMutation) ResourceIDs() (ids []int) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *SlotMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the SlotMutation builder.
func (m *SlotMutation) Where(ps ...predicate.Slot) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SlotMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Slot).
func (m *SlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SlotMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.day != nil {
		fields = append(fields, slot.FieldDay)
	}
	if m.startTime != nil {
		fields = append(fields, slot.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, slot.FieldEndTime)
	}
	if m.quantity != nil {
		fields = append(fields, slot.FieldQuantity)
	}
	if m.resource != nil {
		fields = append(fields, slot.FieldResourceId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slot.FieldDay:
		return m.Day()
	case slot.FieldStartTime:
		return m.StartTime()
	case slot.FieldEndTime:
		return m.EndTime()
	case slot.FieldQuantity:
		return m.Quantity()
	case slot.FieldResourceId:
		return m.ResourceId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slot.FieldDay:
		return m.OldDay(ctx)
	case slot.FieldStartTime:
		return m.OldStartTime(ctx)
	case slot.FieldEndTime:
		return m.OldEndTime(ctx)
	case slot.FieldQuantity:
		return m.OldQuantity(ctx)
	case slot.FieldResourceId:
		return m.OldResourceId(ctx)
	}
	return nil, fmt.Errorf("unknown Slot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slot.FieldDay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay(v)
		return nil
	case slot.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case slot.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case slot.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case slot.FieldResourceId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceId(v)
		return nil
	}
	return fmt.Errorf("unknown Slot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SlotMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, slot.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SlotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slot.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slot.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Slot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SlotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slot.FieldQuantity) {
		fields = append(fields, slot.FieldQuantity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SlotMutation) ClearField(name string) error {
	switch name {
	case slot.FieldQuantity:
		m.ClearQuantity()
		return nil
	}
	return fmt.Errorf("unknown Slot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SlotMutation) ResetField(name string) error {
	switch name {
	case slot.FieldDay:
		m.ResetDay()
		return nil
	case slot.FieldStartTime:
		m.ResetStartTime()
		return nil
	case slot.FieldEndTime:
		m.ResetEndTime()
		return nil
	case slot.FieldQuantity:
		m.ResetQuantity()
		return nil
	case slot.FieldResourceId:
		m.ResetResourceId()
		return nil
	}
	return fmt.Errorf("unknown Slot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resource != nil {
		edges = append(edges, slot.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SlotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slot.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SlotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresource {
		edges = append(edges, slot.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SlotMutation) EdgeCleared(name string) bool {
	switch name {
	case slot.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SlotMutation) ClearEdge(name string) error {
	switch name {
	case slot.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Slot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SlotMutation) ResetEdge(name string) error {
	switch name {
	case slot.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Slot edge %s", name)
}

// UnavailabilityMutation represents an operation that mutates the Unavailability nodes in the graph.
type UnavailabilityMutation struct {
	config
	op              Op
	typ             string
	id              *int
	createdAt       *time.Time
	updatedAt       *time.Time
	startTime       *time.Time
	endTime         *time.Time
	clearedFields   map[string]struct{}
	resource        *int
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*Unavailability, error)
	predicates      []predicate.Unavailability
}

var _ ent.Mutation = (*UnavailabilityMutation)(nil)

// unavailabilityOption allows management of the mutation configuration using functional options.
type unavailabilityOption func(*UnavailabilityMutation)

// newUnavailabilityMutation creates new mutation for the Unavailability entity.
func newUnavailabilityMutation(c config, op Op, opts ...unavailabilityOption) *UnavailabilityMutation {
	m := &UnavailabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeUnavailability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnavailabilityID sets the ID field of the mutation.
func withUnavailabilityID(id int) unavailabilityOption {
	return func(m *UnavailabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Unavailability
		)
		m.oldValue = func(ctx context.Context) (*Unavailability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Unavailability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnavailability sets the old Unavailability of the mutation.
func withUnavailability(node *Unavailability) unavailabilityOption {
	return func(m *UnavailabilityMutation) {
		m.oldValue = func(context.Context) (*Unavailability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnavailabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnavailabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UnavailabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "createdAt" field.
func (m *UnavailabilityMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UnavailabilityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Unavailability entity.
// If the Unavailability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnavailabilityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UnavailabilityMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UnavailabilityMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UnavailabilityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Unavailability entity.
// If the Unavailability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnavailabilityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UnavailabilityMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetStartTime sets the "startTime" field.
func (m *UnavailabilityMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *UnavailabilityMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Unavailability entity.
// If the Unavailability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnavailabilityMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *UnavailabilityMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *UnavailabilityMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *UnavailabilityMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Unavailability entity.
// If the Unavailability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnavailabilityMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *UnavailabilityMutation) ResetEndTime() {
	m.endTime = nil
}

// SetResourceId sets the "resourceId" field.
func (m *UnavailabilityMutation) SetResourceId(i int) {
	m.resource = &i
}

// ResourceId returns the value of the "resourceId" field in the mutation.
func (m *UnavailabilityMutation) ResourceId() (r int, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceId returns the old "resourceId" field's value of the Unavailability entity.
// If the Unavailability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnavailabilityMutation) OldResourceId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResourceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResourceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceId: %w", err)
	}
	return oldValue.ResourceId, nil
}

// ResetResourceId resets all changes to the "resourceId" field.
func (m *UnavailabilityMutation) ResetResourceId() {
	m.resource = nil
}

// SetResourceID sets the "resource" edge to the Resource entity by id.
func (m *UnavailabilityMutation) SetResourceID(id int) {
	m.resource = &id
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *UnavailabilityMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *UnavailabilityMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceID returns the "resource" edge ID in the mutation.
func (m *UnavailabilityMutation) ResourceID() (id int, exists bool) {
	if m.resource != nil {
		return *m.resource, true
	}
	return
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *UnavailabilityMutation) ResourceIDs() (ids []int) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *UnavailabilityMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the UnavailabilityMutation builder.
func (m *UnavailabilityMutation) Where(ps ...predicate.Unavailability) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UnavailabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Unavailability).
func (m *UnavailabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UnavailabilityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.createdAt != nil {
		fields = append(fields, unavailability.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, unavailability.FieldUpdatedAt)
	}
	if m.startTime != nil {
		fields = append(fields, unavailability.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, unavailability.FieldEndTime)
	}
	if m.resource != nil {
		fields = append(fields, unavailability.FieldResourceId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UnavailabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unavailability.FieldCreatedAt:
		return m.CreatedAt()
	case unavailability.FieldUpdatedAt:
		return m.UpdatedAt()
	case unavailability.FieldStartTime:
		return m.StartTime()
	case unavailability.FieldEndTime:
		return m.EndTime()
	case unavailability.FieldResourceId:
		return m.ResourceId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UnavailabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unavailability.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case unavailability.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case unavailability.FieldStartTime:
		return m.OldStartTime(ctx)
	case unavailability.FieldEndTime:
		return m.OldEndTime(ctx)
	case unavailability.FieldResourceId:
		return m.OldResourceId(ctx)
	}
	return nil, fmt.Errorf("unknown Unavailability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnavailabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unavailability.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case unavailability.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case unavailability.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case unavailability.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case unavailability.FieldResourceId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceId(v)
		return nil
	}
	return fmt.Errorf("unknown Unavailability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UnavailabilityMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UnavailabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnavailabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Unavailability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UnavailabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UnavailabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnavailabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Unavailability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UnavailabilityMutation) ResetField(name string) error {
	switch name {
	case unavailability.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case unavailability.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case unavailability.FieldStartTime:
		m.ResetStartTime()
		return nil
	case unavailability.FieldEndTime:
		m.ResetEndTime()
		return nil
	case unavailability.FieldResourceId:
		m.ResetResourceId()
		return nil
	}
	return fmt.Errorf("unknown Unavailability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UnavailabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resource != nil {
		edges = append(edges, unavailability.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UnavailabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unavailability.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UnavailabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UnavailabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UnavailabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresource {
		edges = append(edges, unavailability.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UnavailabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case unavailability.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UnavailabilityMutation) ClearEdge(name string) error {
	switch name {
	case unavailability.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Unavailability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UnavailabilityMutation) ResetEdge(name string) error {
	switch name {
	case unavailability.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Unavailability edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	createdAt           *time.Time
	updatedAt           *time.Time
	name                *string
	email               *string
	clearedFields       map[string]struct{}
	auths               map[int]struct{}
	removedauths        map[int]struct{}
	clearedauths        bool
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetOrganizationId sets the "organizationId" field.
func (m *UserMutation) SetOrganizationId(i int) {
	m.organization = &i
}

// OrganizationId returns the value of the "organizationId" field in the mutation.
func (m *UserMutation) OrganizationId() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationId returns the old "organizationId" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganizationId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrganizationId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrganizationId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationId: %w", err)
	}
	return oldValue.OrganizationId, nil
}

// ResetOrganizationId resets all changes to the "organizationId" field.
func (m *UserMutation) ResetOrganizationId() {
	m.organization = nil
}

// AddAuthIDs adds the "auths" edge to the Auth entity by ids.
func (m *UserMutation) AddAuthIDs(ids ...int) {
	if m.auths == nil {
		m.auths = make(map[int]struct{})
	}
	for i := range ids {
		m.auths[ids[i]] = struct{}{}
	}
}

// ClearAuths clears the "auths" edge to the Auth entity.
func (m *UserMutation) ClearAuths() {
	m.clearedauths = true
}

// AuthsCleared reports if the "auths" edge to the Auth entity was cleared.
func (m *UserMutation) AuthsCleared() bool {
	return m.clearedauths
}

// RemoveAuthIDs removes the "auths" edge to the Auth entity by IDs.
func (m *UserMutation) RemoveAuthIDs(ids ...int) {
	if m.removedauths == nil {
		m.removedauths = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.auths, ids[i])
		m.removedauths[ids[i]] = struct{}{}
	}
}

// RemovedAuths returns the removed IDs of the "auths" edge to the Auth entity.
func (m *UserMutation) RemovedAuthsIDs() (ids []int) {
	for id := range m.removedauths {
		ids = append(ids, id)
	}
	return
}

// AuthsIDs returns the "auths" edge IDs in the mutation.
func (m *UserMutation) AuthsIDs() (ids []int) {
	for id := range m.auths {
		ids = append(ids, id)
	}
	return
}

// ResetAuths resets all changes to the "auths" edge.
func (m *UserMutation) ResetAuths() {
	m.auths = nil
	m.clearedauths = false
	m.removedauths = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *UserMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *UserMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganizationId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldOrganizationId:
		return m.OrganizationId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldOrganizationId:
		return m.OldOrganizationId(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldOrganizationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationId(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldOrganizationId:
		m.ResetOrganizationId()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.auths != nil {
		edges = append(edges, user.EdgeAuths)
	}
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuths:
		ids := make([]ent.Value, 0, len(m.auths))
		for id := range m.auths {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedauths != nil {
		edges = append(edges, user.EdgeAuths)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuths:
		ids := make([]ent.Value, 0, len(m.removedauths))
		for id := range m.removedauths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauths {
		edges = append(edges, user.EdgeAuths)
	}
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAuths:
		return m.clearedauths
	case user.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAuths:
		m.ResetAuths()
		return nil
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
